<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>GRECHA</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: Arial; max-width:600px; margin:40px auto;
            background-image:url("/public/bg1.jpg"); background-attachment:fixed; background-position:center; }
        h1 { text-align:center; color:ivory; text-shadow:4px 4px 5px #9541AC; }
        #leaderboard { display:flex; flex-direction:column; margin:0 5px; background:rgba(120,103,197,0.8); }
        .leaderboard-header, .leaderboard-item { display:flex; justify-content:space-between; padding:7px;
            box-shadow:0 1px 0 rgba(0,0,0,0.3); }
        .leaderboard-header { position:sticky; top:0; background:#bb37fc; font-weight:700; font-size:18px; }
        .col-1 { width:10%; }
        .col-2 { width:70%; text-align:left; font-family:monospace; overflow:hidden; text-overflow:ellipsis; }
        .col-3 { width:20%; text-align:right; }
        .leaderboard-item .col-1, .leaderboard-item .col-3 { font-size:17px; }
        .leaderboard-item .col-2 { font-weight:700; font-size:16px; }
        .error { color:ivory; text-align:center; padding:10px; }
        .nft-details ul { margin:5px 0 0; padding-left:20px; }
    </style>
</head>
<body>
<h1>GRECHA на feed_yupiks.near</h1>

<div id="filter-controls" style="margin:20px; text-align:center;">
    <label>С:
        <input type="datetime-local" id="since-input" value="2025-07-03T13:50" />
    </label>
    &nbsp;
    <label>По:
        <input type="datetime-local" id="until-input" value="2025-07-05T23:59" />
    </label>
    &nbsp;
    <button id="apply-filter">Применить</button>
</div>

<div id="leaderboard">
    <div class="leaderboard-header">
        <div class="col-1">№</div>
        <div class="col-2">Кошелек</div>
        <div class="col-3">Сумма</div>
    </div>
    <div id="items"></div>
</div>

<script>
    const API_PATH     = '/api/nft-yupik-checker';
    const WALLET_ID    = 'feed_yupiks.near';
    const SYMBOL       = 'GRECHA';
    const BATCH        = 200;
    const MIN_INTERVAL = 5 * 60 * 1000;  // 5 минут

    let lastFetchTime = 0;

    function getFilterRange() {
        const sinceStr = document.getElementById('since-input').value;
        const untilStr = document.getElementById('until-input').value;
        return {
            sinceStr, untilStr,
            sinceMs: new Date(sinceStr).getTime(),
            untilMs: new Date(untilStr).getTime()
        };
    }

    async function fetchAll() {
        let all = [];
        for (let skip = 0; ; skip += BATCH) {
            const url = `${API_PATH}`
                + `?wallet_id=${encodeURIComponent(WALLET_ID)}`
                + `&symbol=${encodeURIComponent(SYMBOL)}`
                + `&limit=${BATCH}`
                + `&skip=${skip}`;
            const resp = await fetch(url);
            if (!resp.ok) throw new Error(`API ${resp.status}`);
            const { transfers } = await resp.json();
            if (!Array.isArray(transfers) || transfers.length === 0) break;
            all.push(...transfers);
            if (transfers.length < BATCH) break;
        }
        return all;
    }

    async function renderBoard() {
        const now = Date.now();
        if (now - lastFetchTime < MIN_INTERVAL) return;
        lastFetchTime = now;

        const { sinceStr, untilStr, sinceMs, untilMs } = getFilterRange();
        const container = document.getElementById('items');
        container.innerHTML = '';

        try {
            let data = await fetchAll();
            data = data.filter(tx => {
                const txMs = Number(tx.timestamp_nanosec) / 1e6;
                return txMs >= sinceMs && txMs <= untilMs;
            });

            const stats = {};
            data.forEach(tx => {
                const wallet = tx.from;
                const txMs = Number(tx.timestamp_nanosec) / 1e6;
                const amount = parseFloat(tx.amount) / 1000 || 0;
                if (!stats[wallet]) stats[wallet] = { total: 0, firstMs: txMs };
                stats[wallet].total += amount;
                if (txMs < stats[wallet].firstMs) stats[wallet].firstMs = txMs;
            });

            const sorted = Object.entries(stats)
                .map(([wallet, { total, firstMs }]) => ({ wallet, total, firstMs }))
                .sort((a, b) => a.firstMs - b.firstMs);

            if (sorted.length === 0) {
                container.innerHTML = `
            <div class="error">
              Нет переводов в период<br>
              ${sinceStr.replace('T',' ')} — ${untilStr.replace('T',' ')}
            </div>`;
                return;
            }

            sorted.forEach((item, i) => {
                const row = document.createElement('div');
                row.className = 'leaderboard-item';
                row.innerHTML = `
            <div class="col-1">${i + 1}</div>
            <div class="col-2">${item.wallet}</div>
            <div class="col-3">${item.total.toLocaleString(undefined, {
                    minimumFractionDigits: 3,
                    maximumFractionDigits: 3
                })}</div>`;
                row.dataset.wallet = item.wallet;
                container.appendChild(row);

                row.addEventListener('click', async () => {
                    let details = row.nextElementSibling;
                    if (details && details.classList.contains('nft-details')) {
                        details.style.display = details.style.display === 'none' ? '' : 'none';
                        return;
                    }
                    try {
                        const resp = await fetch(
                            `${API_PATH}?owner_id=${encodeURIComponent(item.wallet)}&contract_address=darai.mintbase1.near`
                        );
                        const data = await resp.json();
                        // Берём массив из data.nfts
                        const tokens = Array.isArray(data.nfts) ? data.nfts : [];

                        const groups = [
                            'common','uncommon','rare','epic','legendary',
                            '4th generation','3 generations','2nd generation','1st generation','0 generation'
                        ]
                            // Сортируем так, чтобы 'uncommon' (9 символов) шёл раньше 'common' (6 символов)
                            .sort((a, b) => b.length - a.length);

                        const counts = {};
                        groups.forEach(g => counts[g] = 0);

                        tokens.forEach(token => {
                            const title = (token.metadata?.title || '').toLowerCase();
                            const found = groups.find(g => title.includes(g));
                            if (found) counts[found]++;
                        });

                        details = document.createElement('div');
                        details.className = 'nft-details';
                        details.style.padding = '0 5px 5px 25px';
                        details.innerHTML = `<strong>NFT по группам:</strong>
                <ul>${Object.entries(counts)
                            .filter(([_,c]) => c > 0)
                            .map(([g,c]) => `<li>${g}: ${c}</li>`)
                            .join('')}</ul>`;

                        row.insertAdjacentElement('afterend', details);
                    } catch (err) {
                        console.error(err);
                    }
                });
            });
        } catch (err) {
            container.innerHTML = `<div class="error">Ошибка: ${err.message}</div>`;
            console.error(err);
        }
    }

    document.getElementById('apply-filter').addEventListener('click', renderBoard);
    window.addEventListener('DOMContentLoaded', renderBoard);
</script>
</body>
</html>
