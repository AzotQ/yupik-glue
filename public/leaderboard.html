<!-- grecha.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>GRECHA</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 40px auto;
            background-image: url("/public/bg1.jpg");
            background-attachment: fixed;
            background-position: center;
        }
        h1 {
            text-align: center;
            color: ivory;
            text-shadow: 4px 4px 5px #9541AC;
        }
        #leaderboard {
            display: flex;
            flex-direction: column;
            margin: 0 5px;
            background: rgb(120 103 197 / 80%);
        }
        .leaderboard-header, .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 7px;
            box-shadow: 0 1px 0 rgba(0,0,0,0.3);
        }
        .leaderboard-header {
            position: sticky;
            top: 0;
            background: #bb37fc;
            font-weight: 700;
            font-size: 18px;
        }
        .col-1 { width: 10%; }
        .col-2 {
            width: 70%;
            text-align: left;
            font-family: monospace;
            font-weight: 700;
            font-size: 16px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .col-3 {
            width: 20%;
            text-align: right;
            font-size: 17px;
        }
        .error {
            color: ivory;
            text-align: center;
            padding: 10px;
        }
        /* Стили для деталей NFT */
        .nft-details {
            margin: 0 5px 20px;
            background: rgb(120 103 197 / 60%);
            padding: 10px;
            border-radius: 8px;
        }
        .nft-details table {
            width: 100%;
            border-collapse: collapse;
        }
        .nft-details th, .nft-details td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.3);
        }
        .nft-details th {
            font-weight: 700;
        }
    </style>
</head>
<body>
<h1>GRECHA на feed_yupiks.near</h1>

<!-- Filter by date/time range -->
<div id="filter-controls" style="margin: 20px; text-align: center;">
    <label>
        С:
        <input type="datetime-local" id="since-input" value="2025-07-03T13:50" />
    </label>
    &nbsp;
    <label>
        По:
        <input type="datetime-local" id="until-input" value="2025-07-05T23:59" />
    </label>
    &nbsp;
    <button id="apply-filter">Применить</button>
</div>

<template id="nft-details-template">
    <div class="nft-details">
        <table>
            <thead>
            <tr>
                <th>Группа</th>
                <th>Количество</th>
            </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</template>

<div id="leaderboard">
    <div class="leaderboard-header">
        <div class="col-1">№</div>
        <div class="col-2">Кошелек</div>
        <div class="col-3">Сумма</div>
    </div>
    <div id="items"></div>
</div>

<script>
    // Константы API
    const API_PATH           = '/api/nft-yupik-checker';
    const WALLET_ID          = 'feed_yupiks.near';
    const SYMBOL             = 'GRECHA';
    const BATCH              = 200;
    const MIN_INTERVAL       = 5 * 60 * 1000;  // 5 минут
    const NFT_API_BASE       = 'https://dialog-tbot.com/nft/by-owner-contract/';
    const CONTRACT_ADDRESS   = 'darai.mintbase1.near';

    // Группы по ключевым словам в title (без учёта регистра)
    const NFT_GROUPS = [
        'common','uncommon','rare','epic','legendary',
        '4th generation','3th generation','2th generation','1th generation','0 generation'
    ];

    let lastFetchTime = 0;

    function getFilterRange() {
        const sinceStr = document.getElementById('since-input').value;
        const untilStr = document.getElementById('until-input').value;
        return {
            sinceStr,
            untilStr,
            sinceMs: new Date(sinceStr).getTime(),
            untilMs: new Date(untilStr).getTime()
        };
    }

    async function fetchAll() {
        let all = [];
        for (let skip = 0; ; skip += BATCH) {
            const url = `${API_PATH}`
                + `?wallet_id=${encodeURIComponent(WALLET_ID)}`
                + `&symbol=${encodeURIComponent(SYMBOL)}`
                + `&limit=${BATCH}`
                + `&skip=${skip}`;
            const resp = await fetch(url);
            if (!resp.ok) throw new Error(`API ${resp.status}`);
            const { transfers } = await resp.json();
            if (!Array.isArray(transfers) || transfers.length === 0) break;
            all.push(...transfers);
            if (transfers.length < BATCH) break;
        }
        return all;
    }

    async function renderBoard() {
        const now = Date.now();
        if (now - lastFetchTime < MIN_INTERVAL) return;
        lastFetchTime = now;

        const { sinceStr, untilStr, sinceMs, untilMs } = getFilterRange();
        const container = document.getElementById('items');
        container.innerHTML = '';

        try {
            let data = await fetchAll();
            data = data.filter(tx => {
                const txMs = Number(tx.timestamp_nanosec) / 1e6;
                return txMs >= sinceMs && txMs <= untilMs;
            });

            const stats = {};
            data.forEach(tx => {
                const wallet = tx.from;
                const txMs = Number(tx.timestamp_nanosec) / 1e6;
                const amount = parseFloat(tx.amount) / 1000 || 0;
                if (!stats[wallet]) stats[wallet] = { total: 0, firstMs: txMs };
                stats[wallet].total += amount;
                if (txMs < stats[wallet].firstMs) stats[wallet].firstMs = txMs;
            });

            const sorted = Object.entries(stats)
                .map(([wallet,{total,firstMs}])=>({wallet,total,firstMs}))
                .sort((a,b)=>a.firstMs-b.firstMs);

            if (sorted.length === 0) {
                container.innerHTML = `
                  <div class="error">
                    Нет переводов в период<br>
                    ${sinceStr.replace('T',' ')} — ${untilStr.replace('T',' ')}
                  </div>`;
                return;
            }

            sorted.forEach((item,i)=> {
                const row = document.createElement('div');
                row.className = 'leaderboard-item';
                row.innerHTML = `
                  <div class="col-1">${i+1}</div>
                  <div class="col-2">${item.wallet}</div>
                  <div class="col-3">${item.total.toLocaleString(undefined,{
                    minimumFractionDigits:3,maximumFractionDigits:3
                })}</div>`;
                row.addEventListener('click',()=>toggleNFTDetails(item.wallet,row));
                container.appendChild(row);
            });
        } catch (err) {
            container.innerHTML = `<div class="error">Ошибка: ${err.message}</div>`;
            console.error(err);
        }
    }

    // Переключает отображение блока с деталями NFT
    async function toggleNFTDetails(wallet, row) {
        const next = row.nextElementSibling;
        if (next && next.classList.contains('nft-details')) {
            next.remove();
            return;
        }
        const details = document.getElementById('nft-details-template').content.cloneNode(true);
        const tbody = details.querySelector('tbody');
        row.after(details);
        try {
            const groups = await fetchAndGroupNFTs(wallet);
            for (const [group, count] of Object.entries(groups)) {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${group}</td><td>${count}</td>`;
                tbody.appendChild(tr);
            }
        } catch (err) {
            tbody.innerHTML = `<tr><td colspan="2">Ошибка загрузки NFT: ${err.message}</td></tr>`;
        }
    }

    // Запрашивает NFT и группирует их по ключевым словам в metadata.title
    async function fetchAndGroupNFTs(ownerId) {
        const url = new URL(NFT_API_BASE);
        url.searchParams.set('owner_id', ownerId);
        url.searchParams.set('contract_address', CONTRACT_ADDRESS);

        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`API ${resp.status}`);
        const data = await resp.json();
        // теперь массив лежит в data.nfts
        const tokens = Array.isArray(data.nfts) ? data.nfts : [];

        // инициализируем счётчики групп
        const counts = NFT_GROUPS.reduce((acc,g)=>{ acc[g]=0; return acc; },{});

        tokens.forEach(token => {
            // берём заголовок из metadata.title
            const title = (token.metadata?.title || '').toLowerCase();
            for (const group of NFT_GROUPS) {
                if (title.includes(group.toLowerCase())) {
                    counts[group]++;
                    break;
                }
            }
        });

        return counts;
    }

    document.getElementById('apply-filter').addEventListener('click', renderBoard);
    window.addEventListener('DOMContentLoaded', renderBoard);
</script>
</body>
</html>
